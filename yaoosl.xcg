@SKIP \ \r\n\t
@CASESENSITIVE true
@LINECOMMENTSTART \/\/
@BLOCKCOMMENTSTART \/\*
@BLOCKCOMMENTEND \*\/

name => (a-zA-Z\_)(a-zA-Z0-9\_)+;
colon = ":" > \:;
class => class;
operator => operator;
curlyo = "{" > \{;
curlyc = "}" > \};
roundo = "(" > \(;
roundc = ")" > \);
squareo = "[" > \[;
squarec = "]" > \];
sc = ";" > \;;
comma = "," > \,;
get => get;
set => set;
this => this;
plusplus = "++" > \+\+;
plus = "+" > \+;
minusminus = "--" > \-\-;
minus = "-" > \-;
times = "*" > \*;
divided = "/" > \/;
ltlt = "<<" > \<\<;
gtgt = ">>" > \>\>;
lteq = "<=" > \<\=;
gteq = ">=" > \>\=;
lt = "<" > \<;
gt = ">" > \>;
eqeq = "==" > \=\=;
noteq = "!=" > \!\=;
not = "!" > \!;
invert = "~" > \~;
modulo = "%" > \%;
index = "[]" > \[\];
typeof => typeof;
is => is;
var => var;
eq = "=" > \=;
eqxor = "^=" > \^\=;
eqor = "|=" > \|\=;
eqand = "&=" > \&\=;
eqdivided = "/=" > \/\=;
eqtimes = "*=" > \*\=;
eqminus = "-=" > \-\=;
eqplus = "+=" > \+\=;
questionmark = "?" > \?;
logicaland = "&&" > \&\&;
logicalor = "||" > \|\|;
and = "&" > \?;
or = "|" > \|;
as => as;
true => true;
false => false;
dot = "." > \.;
number => (0-9)+;
string =? 0;
new => new;
private => private;
protected => protected;
internal => internal;
public => public;
static => static;
if => if;
else => else;
for => for;
while => while;
do => do;
try => try;
catch => catch;
throw => throw;
null => null;
break => break;
continue => continue;
return => return;
any => .;

IDENT = name { dot name };
YAOOSL = { CLASS | CODE };
CLASS = class IDENT [ colon IDENT { comma IDENT } ] curlyo { METHOD | PROPERTY } curlyc;
ENCAPSULATION = private | protected | internal | public | static;
METHOD =  METHODIDENT METHODARGS METHODBODY;
OPERATOR = plusplus | minusminus | plus | minus | times | divided | ltlt | gtgt | lteq | gteq | lt | gt | eqeq | noteq | not | modulo | index ( get | set ) | logicalor | logicaland | and | or | invert;
METHODIDENT = operator [ this ] OPERATOR | ENCAPSULATION IDENT [ name ];
METHODARGS = roundo [ IDENT name { comma IDENT name } ] roundc;
METHODBODY = curlyo { CODE } curlyc;
PROPERTY = IDENT name ( sc | curlyo ( get METHODBODY [ set METHODBODY ] | set METHODBODY [ get METHODBODY ] ) curlyc );
CODE = sc | THROW | IF | FOR | WHILE | DOWHILE | TRYCATCH | continue | break | EXPRESSION sc;
EXPRESSION = EXP01;
EXP01 = EXP02 [ questionmark EXPRESSION colon EXPRESSION ];
EXP02 = EXP03 [ logicalor EXPRESSION ];
EXP03 = EXP04 [ logicaland EXPRESSION ];
EXP04 = EXP05 [ or EXPRESSION ];
EXP05 = EXP06 [ and EXPRESSION ];
EXP06 = EXP07 [ ( eqeq | noteq ) EXPRESSION ];
EXP07 = EXP08 [ ( lteq | gteq | lt | gt | is ) EXPRESSION ];
EXP08 = EXP09 [ ( ltlt | gtgt ) EXPRESSION ];
EXP09 = EXP10 [ ( plus | minus ) EXPRESSION ];
EXP10 = EXP11 [ ( times | divided | modulo ) EXPRESSION ];
EXP11 = EXP12 [ plusplus | minusminus ];
EXP12 = UNARY | VALUE | BRACEDEXP [ dot IDENT [ ( CALL | eq EXPRESSION ) ] ] | IDENT [ ( CALL | name eq EXPRESSION | eq EXPRESSION ) ];
BRACEDEXP = roundo EXPRESSION roundc;
UNARY = new IDENT CALL | not EXP12 | invert EXP12 | typeof roundo IDENT roundc | return EXPRESSION;
VALUE = NUMBER | STRING | true | false | null;
NUMBER = dot number | number [ dot number ];
STRING = string;
CODEBODY = CODE | curlyo { CODE } curlyc;
IF = if roundo EXPRESSION roundc CODEBODY [ else CODEBODY ];
FOR = for roundo [ EXPRESSION { comma EXPRESSION } ] sc [ EXPRESSION ] sc [ EXPRESSION { comma EXPRESSION } ] roundc CODEBODY;
WHILE = while roundo EXPRESSION roundc CODEBODY;
DOWHILE = do CODEBODY while roundo EXPRESSION roundc;
TRYCATCH = try CODEBODY { catch IDENT name CODEBODY };
THROW = throw EXPRESSION;
CALL = roundo [ EXPRESSION { comma EXPRESSION } ] roundc;
